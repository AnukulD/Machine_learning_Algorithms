# -*- coding: utf-8 -*-
"""Assign2_1_i.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1akQE3OfhOPg2LlDWa4b_kLnTGFSCJ0vl
"""

from google.colab import drive
drive.mount('/content/drive')

import pandas as pd
import numpy as np
url = '/content/drive/MyDrive/Colab Notebooks/A2Q1.csv'
df=pd.read_csv(url , header = None)
# df._get_value(0 , 'A')
# x = df.iloc[0:,0:100]
df

#Initialization
def Initialization(df,Z, k):
  import random
  centroid = []
  # print(Z)
  for i in range(k):
    r = random.randint(0,400)
    Z[r] = i+1
    centroid.append(df.iloc[r])
    # print(r)
  return Z , centroid

def EuclideanDist (A , B):
  return np.sqrt(np.sum((A - B)**2))

def CalculateMean(centroid ,Z ,k):
    centroid = np.zeros((k+1,50))
    Times = np.zeros(k+1)
    for i in range(len(df)):  
      for j in range(k+1):
        if Z[i] == (j+1):
          # print(j+1, df.iloc[i] )
          centroid[j] = np.add(centroid[j], df.iloc[i])
          Times[j] = Times[j] + 1
    # print(Times)
    for j in range(k):
      # n = np.count_nonzero(j+1)
      # print(n)
      centroid[j] = np.multiply(centroid[j] , 1 / Times[j])
      # print(centroid[j])
    return centroid

def Reassignment(centroid , Z , k):
  isReassign = False
  # print('Reasssss')
  for i in range(len(df)):
    # print(Z[i]-1)
    # dist = 10000
    # print('Z[i] ' , Z[i])
    if Z[i] == 0:
      dist = 10000
    else:
      dist = EuclideanDist(centroid[int(Z[i]) - 1], df.iloc[i])
    for j in range(k):
      ED  = EuclideanDist(centroid[j] , df.iloc[i])
      if dist > ED:
        isReassign = True
        dist = ED
        # print('From ', Z[i])
        Z[i] = j+1
        # print('df' ,df.iloc[i] , 'To  ',Z[i] )
  return Z, isReassign

def PlotGraph(k,df,Z):
  colour = ['Red', 'Green' , 'Cyan' , 'Black' , 'Blue', 'Purple']
  import matplotlib.pyplot as plt
  # print(colour)
  Plot =  [] 
  for i in range(0,k):
    Plot1 = []
    for j in range(len(df)):
      if Z[j] == i+1:
        Plot1.append(df.iloc[j])
    Plot1 = pd.DataFrame(Plot1)
    # print(Plot1)
    plt.scatter(Plot1['A'] , Plot1['B'],color=colour[i])

def Clustering(k): 
  Z = np.zeros(400)
  Z, centroid = Initialization(df,Z , k)
  centroid
  # type(centroid)
  Z, isReassign = Reassignment(centroid, Z, k)
  while isReassign:
    CalculateMean(centroid, Z , k)
    Z, isReassign = Reassignment(centroid, Z, k)
  return Z
  # CommputeError(Z , centroid)
  # PlotGraph(k,df, Z)

k = 4
Z = np.zeros(400)
Z, centroid = Initialization(df,Z , k)
centroid  = np.array(centroid)
Z, isReassign = Reassignment(centroid, Z, k)
while isReassign:
  centroid = CalculateMean(centroid, Z, k)
  Z, isReassign = Reassignment(centroid, Z, k)
centroid  = np.array(centroid)


print(centroid.shape)
print(Z)

mu = centroid 
print(mu)
mu = np.delete(mu, 4, axis=0)

def InitcomputeP(mu):
  P = mu.sum(axis = 1)
  P = np.multiply(1 / 50 , P)
  print(P.shape)
  return P

def InitcomputePi(Z):
  Pi = []
  c1 = c2 = c3 = c4 = 0
  for i in Z: 
    if i == 1: 
      c1 = c1 + 1
    elif i == 2:
      c2 = c2 + 1
    elif i == 3: 
      c3 = c3 + 1
    elif i == 4:
      c4 = c4 + 1
  p1 = c1 / 400
  p2 = c2 / 400
  p3 = c3 / 400
  p4 = c4 / 400
  Pi.append(p1)
  Pi.append(p2)
  Pi.append(p3)
  Pi.append(p4)
  return Pi

P = InitcomputeP(mu)
print(P)
Pi = InitcomputePi(Z)
print(Pi)

def computexi():
  no_ones = []
  for i in range(400):
    one = np.sum(df.iloc[i,0:])
    no_ones.append(one)
  print(no_ones)
  return no_ones

no_ones = computexi()

import numpy as np
def computeLambda(Pi, P, no_ones):
  lammbda = np.zeros((400 ,4))
  for i in range(400):
    denomin = 0
    for j in range(4):
      denomin = denomin + Pi[j] * P[j]**no_ones[i] * (1-P[j])**(50 - no_ones[i])
    for k in range(4):
      numret = Pi[j] * np.power(P[j],no_ones[i]) * np.power((1-P[j]), (50 - no_ones[i]))
      lamd = numret / denomin
      lammbda[i][k] = lamd
  print(lammbda)
  return lammbda

lammbda = computeLambda(Pi, P, no_ones)

def computeP(lammbda , no_ones):
  P = np.zeros(4)
  numer = 0
  denom = np.sum(lammbda, axis = 0)
  print(denom)
  for i in range(4):
    for j in range(400):
      numer = numer + lammbda[j][i] * (no_ones[j]/50)
      # print(numer)
    numer = numer / denom[i]
    P[i] = numer
  return P
  

P = computeP(lammbda, no_ones)
print('P' , P)

def computeLogLikelihood(Pi, P, no_ones):
  loglike = []
  for i in range(400):
    nume = 0
    for j in range(4):
      nume = nume + np.power(P[j], no_ones[i]) * np.power((1-P[j]), (50 - no_ones[i]))
    nume = np.log(nume)
    loglike.append(nume)
  return loglike
loglike = computeLogLikelihood(Pi, P, no_ones)
loglike = np.array(loglike)
print(loglike)


# -*- coding: utf-8 -*-
"""Assign2_1_iii.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1v4ybIlGgaPOpFJCkdYcEKWuZEywvexMS
"""

#Mounting drive on the colab
from google.colab import drive
drive.mount('/content/drive')

#importing the file on the colab.
import pandas as pd
import numpy as np
url = '/content/drive/MyDrive/Colab Notebooks/A2Q1.csv'
df=pd.read_csv(url , header = None)
df

#Initialization of the K means 
def Initialization(df,Z, k):
  import random
  centroid = []
  for i in range(k):
    r = random.randint(0,400)
    Z[r] = i+1
    centroid.append(df.iloc[r])
  return Z , centroid

# Computing the Euclidean distcance for the error. 
def EuclideanDist (A , B):
  return np.sqrt(np.sum((A - B)**2))

# Computing the error of the assignment step.
def ComputeError(Z , centroid, k):
  sum = 0
  for i in range(len(df)):
    for j in range(0,k):
      if Z[i] == j+1:
        sum = sum + EuclideanDist(df.iloc[i], centroid[j])
  return sum

# Computing the mean of each of the clusters.
def CalculateMean(centroid ,Z ,k):
    centroid = np.zeros((k+1,50))
    Times = np.zeros(k+1)
    for i in range(len(df)):  
      for j in range(k+1):
        if Z[i] == (j+1):
          centroid[j] = np.add(centroid[j], df.iloc[i])
          Times[j] = Times[j] + 1
    for j in range(k):
      centroid[j] = np.multiply(centroid[j] , 1 / Times[j])
    return centroid

# Computing the reassignment of each of the points for the clusters.
def Reassignment(centroid , Z , k):
  isReassign = False
  for i in range(len(df)):
    if Z[i] == 0:
      dist = 10000
    else:
      dist = EuclideanDist(centroid[int(Z[i]) - 1], df.iloc[i])
    for j in range(k):
      ED  = EuclideanDist(centroid[j] , df.iloc[i])
      if dist > ED:
        isReassign = True
        dist = ED
        Z[i] = j+1
  return Z, isReassign

# Plotting the graph of Error v/s No of iterations
def PlotError(ErrorSum):
  import matplotlib.pyplot as plt
  Iter = [] 
  for i in range(len(ErrorSum)):
    Iter.append(i)
  plt.scatter(Iter,ErrorSum)
  plt.title('Error v/s Iteration')
  plt.xlabel('Error')
  plt.ylabel('No of Iterations')
  plt.show()

# Running th K Means algorithm for K = 4
k = 4
Z = np.zeros(400)
ErrorSum = []
Z, centroid = Initialization(df,Z , k)
centroid  = np.array(centroid)
Z, isReassign = Reassignment(centroid, Z, k)
ErrorSum.append(ComputeError(Z, centroid , k))

while isReassign:
  centroid = CalculateMean(centroid, Z, k)
  Z, isReassign = Reassignment(centroid, Z, k)
  ErrorSum.append(ComputeError(Z, centroid , k))
centroid  = np.array(centroid)

PlotError(ErrorSum)
print(ErrorSum)